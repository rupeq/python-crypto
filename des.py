# Начальная перестановка
IP = [58, 50, 42, 34, 26, 18, 10, 2, 60, 52, 44, 36, 28, 20, 12, 4,
      62, 54, 46, 38, 30, 22, 14, 6, 64, 56, 48, 40, 32, 24, 16, 8,
      57, 49, 41, 33, 25, 17, 9, 1, 59, 51, 43, 35, 27, 19, 11, 3,
      61, 53, 45, 37, 29, 21, 13, 5, 63, 55, 47, 39, 31, 23, 15, 7]

# Функция выбора и перестановки последовательности В
# преобразование ключа шифрования
B = [57, 49, 41, 33, 25, 17, 9, 1, 58, 50, 42, 34, 26, 18,
        10, 2, 59, 51, 43, 35, 27, 19, 11, 3, 60, 52, 44, 36,
        63, 55, 47, 39, 31, 23, 15, 7, 62, 54, 46, 38, 30, 22,
        14, 6, 61, 53, 45, 37, 29, 21, 13, 5, 28, 20, 12, 4]

# Получение последовательностей К(i)
H = [14, 17, 11, 24, 1, 5, 3, 28, 15, 6, 21, 10,
        23, 19, 12, 4, 26, 8, 16, 7, 27, 20, 13, 2,
        41, 52, 31, 37, 47, 55, 30, 40, 51, 45, 33, 48,
        44, 49, 39, 56, 34, 53, 46, 42, 50, 36, 29, 32]

# Функция Е (шифрование, перестановка с расширением)
E = [32, 1, 2, 3, 4, 5, 4, 5, 6, 7, 8, 9,
     8, 9, 10, 11, 12, 13, 12, 13, 14, 15, 16, 17,
     16, 17, 18, 19, 20, 21, 20, 21, 22, 23, 24, 25,
     24, 25, 26, 27, 28, 29, 28, 29, 30, 31, 32, 1]

# Для подстановки в S блоки
S_BOX = [
        [ #s1
            [14, 4, 13, 1, 2, 15, 11, 8, 3, 10, 6, 12, 5, 9, 0, 7],
            [0, 15, 7, 4, 14, 2, 13, 1, 10, 6, 12, 11, 9, 5, 3, 8],
            [4, 1, 14, 8, 13, 6, 2, 11, 15, 12, 9, 7, 3, 10, 5, 0],
            [15, 12, 8, 2, 4, 9, 1, 7, 5, 11, 3, 14, 10, 0, 6, 13],
        ],
        [ #s2
            [15, 1, 8, 14, 6, 11, 3, 4, 9, 7, 2, 13, 12, 0, 5, 10],
            [3, 13, 4, 7, 15, 2, 8, 14, 12, 0, 1, 10, 6, 9, 11, 5],
            [0, 14, 7, 11, 10, 4, 13, 1, 5, 8, 12, 6, 9, 3, 2, 15],
            [13, 8, 10, 1, 3, 15, 4, 2, 11, 6, 7, 12, 0, 5, 14, 9],
        ],
        [ #s3
            [10, 0, 9, 14, 6, 3, 15, 5, 1, 13, 12, 7, 11, 4, 2, 8],
            [13, 7, 0, 9, 3, 4, 6, 10, 2, 8, 5, 14, 12, 11, 15, 1],
            [13, 6, 4, 9, 8, 15, 3, 0, 11, 1, 2, 12, 5, 10, 14, 7],
            [1, 10, 13, 0, 6, 9, 8, 7, 4, 15, 14, 3, 11, 5, 2, 12],
        ],
        [ #s4
            [7, 13, 14, 3, 0, 6, 9, 10, 1, 2, 8, 5, 11, 12, 4, 15],
            [13, 8, 11, 5, 6, 15, 0, 3, 4, 7, 2, 12, 1, 10, 14, 9],
            [10, 6, 9, 0, 12, 11, 7, 13, 15, 1, 3, 14, 5, 2, 8, 4],
            [3, 15, 0, 6, 10, 1, 13, 8, 9, 4, 5, 11, 12, 7, 2, 14],
        ],
        [ #s5
            [2, 12, 4, 1, 7, 10, 11, 6, 8, 5, 3, 15, 13, 0, 14, 9],
            [14, 11, 2, 12, 4, 7, 13, 1, 5, 0, 15, 10, 3, 9, 8, 6],
            [4, 2, 1, 11, 10, 13, 7, 8, 15, 9, 12, 5, 6, 3, 0, 14],
            [11, 8, 12, 7, 1, 14, 2, 13, 6, 15, 0, 9, 10, 4, 5, 3],
        ],
        [ #s6
            [12, 1, 10, 15, 9, 2, 6, 8, 0, 13, 3, 4, 14, 7, 5, 11],
            [10, 15, 4, 2, 7, 12, 9, 5, 6, 1, 13, 14, 0, 11, 3, 8],
            [9, 14, 15, 5, 2, 8, 12, 3, 7, 0, 4, 10, 1, 13, 11, 6],
            [4, 3, 2, 12, 9, 5, 15, 10, 11, 14, 1, 7, 6, 0, 8, 13],
        ],
        [ #s7
            [4, 11, 2, 14, 15, 0, 8, 13, 3, 12, 9, 7, 5, 10, 6, 1],
            [13, 0, 11, 7, 4, 9, 1, 10, 14, 3, 5, 12, 2, 15, 8, 6],
            [1, 4, 11, 13, 12, 3, 7, 14, 10, 15, 6, 8, 0, 5, 9, 2],
            [6, 11, 13, 8, 1, 4, 10, 7, 9, 5, 0, 15, 14, 2, 3, 12],
        ],
        [ #s8
            [13, 2, 8, 4, 6, 15, 11, 1, 10, 9, 3, 14, 5, 0, 12, 7],
            [1, 15, 13, 8, 10, 3, 7, 4, 12, 5, 6, 11, 0, 14, 9, 2],
            [7, 11, 4, 1, 9, 12, 14, 2, 0, 6, 10, 13, 15, 3, 5, 8],
            [2, 1, 14, 7, 4, 10, 8, 13, 15, 12, 9, 0, 3, 5, 6, 11],
        ]
]

# Прямая перестановка с помощью Р блоков
P = [16, 7, 20, 21, 29, 12, 28, 17,
     1, 15, 23, 26, 5, 18, 31, 10,
     2, 8, 24, 14, 32, 27, 3, 9,
     19, 13, 30, 6, 22, 11, 4, 25]

# Заключительная обратная перестановка
IP_1 = [40, 8, 48, 16, 56, 24, 64, 32,
        39, 7, 47, 15, 55, 23, 63, 31,
        38, 6, 46, 14, 54, 22, 62, 30,
        37, 5, 45, 13, 53, 21, 61, 29,
        36, 4, 44, 12, 52, 20, 60, 28,
        35, 3, 43, 11, 51, 19, 59, 27,
        34, 2, 42, 10, 50, 18, 58, 26,
        33, 1, 41, 9, 49, 17, 57, 25]

# Сдвиг битов в последовательности ключа
# получение Ci и Di
SHIFT = [1,1,2,2,2,2,2,2,1,2,2,2,2,2,2,1]

def string_to_bit_array(text): # перевод в битовое представление
    array = list()
    for char in text:
        binval = binvalue(char, 8)
        array.extend([int(x) for x in list(binval)]) # + биты в массив
    return array

def bit_array_to_string(array): # из битового массива в строку
    res = r''.join([chr(int(y,2)) for y in [''.join([str(x) for x in bbytes]) for bbytes in  nsplit(array,8)]])
    return res

def binvalue(val, bitsize): # перевод в двоичное строчное представление
    binval = bin(val)[2:] if isinstance(val, int) else bin(ord(val))[2:]
    while len(binval) < bitsize:
        binval = binval.zfill(bitsize)
    return binval

def nsplit(s, n): # разрез массива по заданному размеру
    return [s[k:k+n] for k in range(0, len(s), n)]

ENCRYPT=1
DECRYPT=0

class des():
    def __init__(self):
        self.password = None # ключ
        self.text = None # шифр. текст
        self.keys = list() # массив ключей

    def run(self, key, text, action=ENCRYPT):
        if len(key) < 8:
            raise "Ключ должен быть 8б"
        elif len(key) > 8:
            key = key[:8]
        if len(text) < 8:
            while len(text) < 8:
                text = '0' + text
        self.password = key
        self.text = text

        if len(self.text) % 8 != 0:
            raise "Размер сообщения должен быть кратен 8"

        self.generatekeys() # генерация ключей
        text_blocks = nsplit(self.text, 8) # делим на блоки 64 бита
        result = list()

        for block in text_blocks: # проходим по блокам
            block = string_to_bit_array(block) # переводим в битовое представление
            block = self.permut(block, IP) # начальная перестановка
            g, d = nsplit(block, 32) # делим на два блока по 32 бита
            tmp = None
            for i in range(16): # 16 раундов (+ по 16 ключам)
                d_e = self.expand(d, E) # шифрование, перестановка с расширением E
                if action == ENCRYPT:
                    tmp = self.xor(self.keys[i], d_e) # объединение xor
                else:
                    tmp = self.xor(self.keys[15-i], d_e) # (расшифровака) начинаем с конца
                tmp = self.substitute(tmp) # подстановка через S блок
                tmp = self.permut(tmp, P) # прямая перестановка P
                tmp = self.xor(g, tmp) # xor c левой частью
                g = d # l[i] = R[i - 1]
                d = tmp # R[i] = R изм
            result += self.permut(d+g, IP_1) # склеиваем и делаем окончательную перестановкy
        final_result = ""
        for block in nsplit(result, 8):
            block = [str(i) for i in block]
            tmp = "".join(block)
            final_result += tmp + ' '
        final_res = bit_array_to_string(result)
        if action == DECRYPT:
            return final_res
        return final_res, final_result

    def substitute(self, d_e):# подстановка по S блокам (6 -> 4)
        subblocks = nsplit(d_e, 6) # "разрезаем" массив по 6 бит
        result = list()
        for i in range(len(subblocks)):
            block = subblocks[i]
            row = int(str(block[0])+str(block[5]),2) # строки из 1, 6
            column = int(''.join([str(x) for x in block[1:][:-1]]),2) # столбцы из 2-5
            val = S_BOX[i][row][column] # значение на пересечении для раунды (sblock = i)
            bin = binvalue(val, 4) # перевод в двочную сс 4бит х 8
            result += [int(x) for x in bin]
        return result

    def permut(self, block, table): # перестановка
        return [block[x-1] for x in table]

    def expand(self, block, table): # расширение (=permut)
        return [block[x-1] for x in table]

    def xor(self, t1, t2):
        return [x^y for x,y in zip(t1,t2)]

    def generatekeys(self): # генерация ключей
        self.keys = []
        key = string_to_bit_array(self.password) # переводим входной ключ в 8 бит
        key = self.permut(key, B) # преобразование ключа шифрования В
        g, d = nsplit(key, 28) # делим на левую и правую части
        for i in range(16):# проходим 16 раундов
            g, d = self.shift(g, d, SHIFT[i]) # сдвигаем биты в последовательностях
            tmp = g + d # соединяем последовательности
            self.keys.append(self.permut(tmp, H)) # конкат + таблица Н

    def shift(self, g, d, n): # сдвигаем список по значению
        return g[n:] + g[:n], d[n:] + d[:n]

    def encrypt(self, key, text):
        return self.run(key, text, ENCRYPT)

    def decrypt(self, key, text):
        return self.run(key, text, DECRYPT)

if __name__ == '__main__':
    key = "12345678"
    text= "derevia"
    d = des()
    r = d.encrypt(key, text)
    r2 = d.decrypt(key, r[0])
    print(f"Введено: \n шифруемый текст: {text} \n ключ: {key}")
    print(f'Зашифрованное сообщение в двоичной сс: {r[1]}')
    print(f"Зашифрованное сообщение ANSI: {r[0]}")
    print(f"Расшифрованное сообщение: {r2}")